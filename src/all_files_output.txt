=> ./main.rs
use std::sync::{Arc, Mutex};

use axum::{
    Json, Router,
    extract::{Path, State},
    response::IntoResponse,
    routing::{get, post},
};
use url_shortener::{Service, Storage};

#[tokio::main]
async fn main() {
    let storage = Arc::new(Mutex::new(Storage::new()));

    let app = Router::new()
        .route("/", post(get_code))
        .route("/{code}", get(get_url))
        .with_state(storage);

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

async fn get_url(
    State(storage): State<Arc<Mutex<Storage>>>,
    Path(code): Path<u64>,
) -> impl IntoResponse {
    let storage = storage.lock().unwrap();

    Service::process_get(&storage, code)
}

async fn get_code(
    State(storage): State<Arc<Mutex<Storage>>>,
    Json(url): Json<url_shortener::Url>,
) -> impl IntoResponse {
    let mut storage = storage.lock().unwrap();

    Service::process_post(&mut storage, url)
}


=> ./lib.rs
mod service;
mod storage;

use serde::{Deserialize, Serialize};
pub use service::Service;
pub use storage::Storage;

#[derive(Serialize, Clone, Eq, PartialEq, Hash)]
pub struct Code(pub u64);

#[derive(Deserialize, Clone, Eq, PartialEq, Hash)]
pub struct Url(pub String);

impl From<u64> for Code {
    fn from(value: u64) -> Self {
        Code(value)
    }
}

impl From<&str> for Url {
    fn from(value: &str) -> Self {
        Url(value.to_string())
    }
}

impl From<String> for Url {
    fn from(value: String) -> Self {
        Url(value)
    }
}

impl From<Url> for String {
    fn from(value: Url) -> Self {
        value.0
    }
}


=> ./storage.rs
#![allow(clippy::new_without_default)]
use std::{collections::HashMap, sync::Arc};

use crate::{Code, Service, Url};

// For now i will only use a std hashmap and everything in memory, later i will use a custom
// hashmap function and also a sqlite database for much larger data.
#[derive(Clone)]
pub struct Storage {
    /// Stores the short codes to long codes for GET
    code_to_url: HashMap<Code, Arc<Url>>,

    /// Stores the long codes to short code for when using POST to shorten a url find duplicates
    url_to_code: HashMap<Arc<Url>, Code>,
}

impl Storage {
    pub fn new() -> Self {
        Self {
            code_to_url: HashMap::new(),
            url_to_code: HashMap::new(),
        }
    }

    pub fn get(&self, code: u64) -> Option<Url> {
        let url_ref = self.code_to_url.get(&code.into())?;
        Some((**url_ref).clone())
    }

    pub fn insert(&mut self, url: &str) -> Code {
        let url: Url = url.to_string().into();

        let code = Service::hash(url.clone());

        let url = Arc::new(url);

        self.code_to_url.insert(code.clone(), url.clone());
        self.url_to_code.insert(url, code.clone());

        code
    }

    pub fn inverted_get(&self, url: &str) -> Option<Code> {
        let url: Url = url.into();
        self.url_to_code.get(&url).cloned()
    }
}


=> ./service.rs
use std::hash::{DefaultHasher, Hash, Hasher};

use axum::response::{IntoResponse, Response};

use crate::{Code, Storage, Url};

pub struct Service {}

impl Service {
    pub fn process_post(storage: &mut Storage, url: Url) -> Response {
        if !Self::is_strict_valid_url(&url.0) {
            return (axum::http::StatusCode::NOT_ACCEPTABLE, "Invalid URL").into_response();
        }
        let code: Code = if let Some(code) = storage.inverted_get(&url.0) {
            code
        } else {
            storage.insert(&url.0)
        };

        axum::Json(code).into_response()
    }

    pub fn process_get(storage: &Storage, code: u64) -> Response {
        match storage.get(code) {
            Some(url) => axum::response::Redirect::permanent(&url.0).into_response(),
            None => (
                axum::http::StatusCode::NOT_FOUND,
                "URL not found in our system",
            )
                .into_response(),
        }
    }

    fn is_strict_valid_url(s: &str) -> bool {
        if let Ok(url) = url::Url::parse(s) {
            matches!(url.scheme(), "http" | "https")
                && url.has_host()
                && url.host_str().map(|h| h.contains('.')).unwrap_or(false)
        } else {
            false
        }
    }

    pub fn hash(url: Url) -> Code {
        let mut hasher = DefaultHasher::new();
        url.hash(&mut hasher);
        Code(hasher.finish())
    }
}


=> ./all_files_output.txt


