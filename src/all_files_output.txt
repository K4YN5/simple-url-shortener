=> ./lib.rs
mod service;
mod storage;

use serde::{Deserialize, Serialize};
pub use service::Service;
pub use storage::Storage;

#[derive(Serialize, Clone, Eq, PartialEq, Hash)]
pub struct Code(pub u64);

#[derive(Deserialize, Clone, Eq, PartialEq, Hash)]
pub struct Url(pub String);

impl From<u64> for Code {
    fn from(value: u64) -> Self {
        Code(value)
    }
}

impl From<&str> for Url {
    fn from(value: &str) -> Self {
        Url(value.to_string())
    }
}

impl From<String> for Url {
    fn from(value: String) -> Self {
        Url(value)
    }
}

impl From<Url> for String {
    fn from(value: Url) -> Self {
        value.0
    }
}


=> ./main.rs
use std::sync::Arc;

use axum::{
    Json, Router,
    extract::{Path, State},
    response::IntoResponse,
    routing::{get, post},
};
use url_shortener::{Service, Storage};

#[tokio::main]
async fn main() {
    let storage = Storage::new();
    let service = Arc::new(Service::new(storage));

    let app = Router::new()
        .route("/", post(get_code))
        .route("/{code}", get(get_url))
        .with_state(service);

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

async fn get_url(State(service): State<Arc<Service>>, Path(code): Path<u64>) -> impl IntoResponse {
    service.process_get(code)
}

async fn get_code(
    State(service): State<Arc<Service>>,
    Json(url): Json<url_shortener::Url>,
) -> impl IntoResponse {
    service.process_post(url)
}


=> ./service.rs
use std::{
    hash::{DefaultHasher, Hash, Hasher},
    sync::{Arc, Mutex},
};

use axum::response::{IntoResponse, Response};

use crate::{Code, Storage, Url};

pub struct Service {
    storage: Arc<Mutex<Storage>>,
}

#[allow(dead_code)]
impl Service {
    pub fn new(storage: Storage) -> Self {
        Self {
            storage: Arc::new(Mutex::new(storage)),
        }
    }

    pub fn process_post(&self, url: Url) -> Response {
        let storage = self.storage.lock().unwrap();

        if let Some(code) = storage.inverted_get(&url.0) {
            return axum::Json(code).into_response();
        };

        let is_url_a = Self::is_valid_public_url(&url.0);

        if !is_url_a {
            return (axum::http::StatusCode::NOT_ACCEPTABLE, "Invalid URL").into_response();
        }

        let mut storage = storage;

        let code: Code = storage.insert(&url.0);

        axum::Json(code).into_response()
    }

    pub fn process_get(&self, code: u64) -> Response {
        let storage = self.storage.lock().unwrap();

        match storage.get(code) {
            Some(url) => axum::response::Redirect::permanent(&url.0).into_response(),
            None => (
                axum::http::StatusCode::NOT_FOUND,
                "URL not found in our system",
            )
                .into_response(),
        }
    }

    fn is_strict_valid_url(s: &str) -> bool {
        if let Ok(url) = url::Url::parse(s) {
            matches!(url.scheme(), "http" | "https")
                && url.has_host()
                && url.host_str().map(|h| h.contains('.')).unwrap_or(false)
        } else {
            false
        }
    }

    pub fn is_valid_public_url(url: &str) -> bool {
        // Must start with http:// or https://
        if !(url.starts_with("http://") || url.starts_with("https://")) {
            return false;
        }

        // Strip scheme
        let without_scheme = match url.split_once("://") {
            Some((_, rest)) => rest,
            None => return false,
        };

        // Extract the hostname
        let host = without_scheme
            .split('/')
            .next()
            .unwrap_or("")
            .split('@') // avoid userinfo
            .next_back()
            .unwrap_or("")
            .split(':') // ignore port if present
            .next()
            .unwrap_or("");

        // Reject IP addresses
        if host.parse::<std::net::IpAddr>().is_ok() {
            return false;
        }

        // Basic domain validation: at least one dot, valid chars
        if !host.contains('.') {
            return false;
        }

        if !host
            .chars()
            .all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '.')
        {
            return false;
        }

        true
    }

    pub fn hash(url: Url) -> Code {
        let mut hasher = DefaultHasher::new();
        url.hash(&mut hasher);
        Code(hasher.finish())
    }
}


=> ./storage.rs
#![allow(clippy::new_without_default)]
use std::{collections::HashMap, sync::Arc};

use dashmap::DashMap;

use crate::{Code, Service, Url};

#[derive(Clone)]
pub struct Storage {
    code_to_url: DashMap<Code, Arc<Url>>,
    url_to_code: DashMap<Arc<Url>, Code>,
}

impl Storage {
    pub fn new() -> Self {
        Self {
            code_to_url: DashMap::new(),
            url_to_code: DashMap::new(),
        }
    }

    pub fn get(&self, code: u64) -> Option<Url> {
        let url_ref = self.code_to_url.get(&code.into())?;
        Some((**url_ref).clone())
    }

    pub fn length(&self) -> usize {
        self.code_to_url.len()
    }

    pub fn insert(&mut self, url: &str) -> Code {
        let url: Url = url.to_string().into();

        let code = Service::hash(url.clone());

        let url = Arc::new(url);

        self.code_to_url.insert(code.clone(), url.clone());
        self.url_to_code.insert(url, code.clone());

        code
    }

    pub fn inverted_get(&self, url: &str) -> Option<Code> {
        let url: Url = url.into();
        self.url_to_code.get(&url).map(|r| r.clone())
    }
}


=> ./all_files_output.txt


